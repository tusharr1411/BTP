{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { id } from \"./id\";\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst NegativeOne = BigNumber.from(-1);\nconst Zero = BigNumber.from(0);\nconst One = BigNumber.from(1);\nconst MaxUint256 = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction hexPadRight(value) {\n  const bytes = arrayify(value);\n  const padOffset = bytes.length % 32;\n  if (padOffset) {\n    return hexConcat([bytes, padding.slice(padOffset)]);\n  }\n  return hexlify(bytes);\n}\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\nconst domainFieldTypes = {\n  name: \"string\",\n  version: \"string\",\n  chainId: \"uint256\",\n  verifyingContract: \"address\",\n  salt: \"bytes32\"\n};\nconst domainFieldNames = [\"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"];\nfunction checkString(key) {\n  return function (value) {\n    if (typeof value !== \"string\") {\n      logger.throwArgumentError(\"invalid domain value for \".concat(JSON.stringify(key)), \"domain.\".concat(key), value);\n    }\n    return value;\n  };\n}\nconst domainChecks = {\n  name: checkString(\"name\"),\n  version: checkString(\"version\"),\n  chainId: function (value) {\n    try {\n      return BigNumber.from(value).toString();\n    } catch (error) {}\n    return logger.throwArgumentError(\"invalid domain value for \\\"chainId\\\"\", \"domain.chainId\", value);\n  },\n  verifyingContract: function (value) {\n    try {\n      return getAddress(value).toLowerCase();\n    } catch (error) {}\n    return logger.throwArgumentError(\"invalid domain value \\\"verifyingContract\\\"\", \"domain.verifyingContract\", value);\n  },\n  salt: function (value) {\n    try {\n      const bytes = arrayify(value);\n      if (bytes.length !== 32) {\n        throw new Error(\"bad length\");\n      }\n      return hexlify(bytes);\n    } catch (error) {}\n    return logger.throwArgumentError(\"invalid domain value \\\"salt\\\"\", \"domain.salt\", value);\n  }\n};\nfunction getBaseEncoder(type) {\n  // intXX and uintXX\n  {\n    const match = type.match(/^(u?)int(\\d*)$/);\n    if (match) {\n      const signed = match[1] === \"\";\n      const width = parseInt(match[2] || \"256\");\n      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {\n        logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n      }\n      const boundsUpper = MaxUint256.mask(signed ? width - 1 : width);\n      const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\n      return function (value) {\n        const v = BigNumber.from(value);\n        if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n          logger.throwArgumentError(\"value out-of-bounds for \".concat(type), \"value\", value);\n        }\n        return hexZeroPad(v.toTwos(256).toHexString(), 32);\n      };\n    }\n  }\n  // bytesXX\n  {\n    const match = type.match(/^bytes(\\d+)$/);\n    if (match) {\n      const width = parseInt(match[1]);\n      if (width === 0 || width > 32 || match[1] !== String(width)) {\n        logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n      }\n      return function (value) {\n        const bytes = arrayify(value);\n        if (bytes.length !== width) {\n          logger.throwArgumentError(\"invalid length for \".concat(type), \"value\", value);\n        }\n        return hexPadRight(value);\n      };\n    }\n  }\n  switch (type) {\n    case \"address\":\n      return function (value) {\n        return hexZeroPad(getAddress(value), 32);\n      };\n    case \"bool\":\n      return function (value) {\n        return !value ? hexFalse : hexTrue;\n      };\n    case \"bytes\":\n      return function (value) {\n        return keccak256(value);\n      };\n    case \"string\":\n      return function (value) {\n        return id(value);\n      };\n  }\n  return null;\n}\nfunction encodeType(name, fields) {\n  return \"\".concat(name, \"(\").concat(fields.map(_ref => {\n    let {\n      name,\n      type\n    } = _ref;\n    return type + \" \" + name;\n  }).join(\",\"), \")\");\n}\nexport class TypedDataEncoder {\n  constructor(types) {\n    defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n    defineReadOnly(this, \"_encoderCache\", {});\n    defineReadOnly(this, \"_types\", {});\n    // Link struct types to their direct child structs\n    const links = {};\n    // Link structs to structs which contain them as a child\n    const parents = {};\n    // Link all subtypes within a given struct\n    const subtypes = {};\n    Object.keys(types).forEach(type => {\n      links[type] = {};\n      parents[type] = [];\n      subtypes[type] = {};\n    });\n    for (const name in types) {\n      const uniqueNames = {};\n      types[name].forEach(field => {\n        // Check each field has a unique name\n        if (uniqueNames[field.name]) {\n          logger.throwArgumentError(\"duplicate variable name \".concat(JSON.stringify(field.name), \" in \").concat(JSON.stringify(name)), \"types\", types);\n        }\n        uniqueNames[field.name] = true;\n        // Get the base type (drop any array specifiers)\n        const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n        if (baseType === name) {\n          logger.throwArgumentError(\"circular type reference to \".concat(JSON.stringify(baseType)), \"types\", types);\n        }\n        // Is this a base encoding type?\n        const encoder = getBaseEncoder(baseType);\n        if (encoder) {\n          return;\n        }\n        if (!parents[baseType]) {\n          logger.throwArgumentError(\"unknown type \".concat(JSON.stringify(baseType)), \"types\", types);\n        }\n        // Add linkage\n        parents[baseType].push(name);\n        links[name][baseType] = true;\n      });\n    }\n    // Deduce the primary type\n    const primaryTypes = Object.keys(parents).filter(n => parents[n].length === 0);\n    if (primaryTypes.length === 0) {\n      logger.throwArgumentError(\"missing primary type\", \"types\", types);\n    } else if (primaryTypes.length > 1) {\n      logger.throwArgumentError(\"ambiguous primary types or unused types: \".concat(primaryTypes.map(t => JSON.stringify(t)).join(\", \")), \"types\", types);\n    }\n    defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n    // Check for circular type references\n    function checkCircular(type, found) {\n      if (found[type]) {\n        logger.throwArgumentError(\"circular type reference to \".concat(JSON.stringify(type)), \"types\", types);\n      }\n      found[type] = true;\n      Object.keys(links[type]).forEach(child => {\n        if (!parents[child]) {\n          return;\n        }\n        // Recursively check children\n        checkCircular(child, found);\n        // Mark all ancestors as having this decendant\n        Object.keys(found).forEach(subtype => {\n          subtypes[subtype][child] = true;\n        });\n      });\n      delete found[type];\n    }\n    checkCircular(this.primaryType, {});\n    // Compute each fully describe type\n    for (const name in subtypes) {\n      const st = Object.keys(subtypes[name]);\n      st.sort();\n      this._types[name] = encodeType(name, types[name]) + st.map(t => encodeType(t, types[t])).join(\"\");\n    }\n  }\n  getEncoder(type) {\n    let encoder = this._encoderCache[type];\n    if (!encoder) {\n      encoder = this._encoderCache[type] = this._getEncoder(type);\n    }\n    return encoder;\n  }\n  _getEncoder(type) {\n    // Basic encoder type (address, bool, uint256, etc)\n    {\n      const encoder = getBaseEncoder(type);\n      if (encoder) {\n        return encoder;\n      }\n    }\n    // Array\n    const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n    if (match) {\n      const subtype = match[1];\n      const subEncoder = this.getEncoder(subtype);\n      const length = parseInt(match[3]);\n      return value => {\n        if (length >= 0 && value.length !== length) {\n          logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n        }\n        let result = value.map(subEncoder);\n        if (this._types[subtype]) {\n          result = result.map(keccak256);\n        }\n        return keccak256(hexConcat(result));\n      };\n    }\n    // Struct\n    const fields = this.types[type];\n    if (fields) {\n      const encodedType = id(this._types[type]);\n      return value => {\n        const values = fields.map(_ref2 => {\n          let {\n            name,\n            type\n          } = _ref2;\n          const result = this.getEncoder(type)(value[name]);\n          if (this._types[type]) {\n            return keccak256(result);\n          }\n          return result;\n        });\n        values.unshift(encodedType);\n        return hexConcat(values);\n      };\n    }\n    return logger.throwArgumentError(\"unknown type: \".concat(type), \"type\", type);\n  }\n  encodeType(name) {\n    const result = this._types[name];\n    if (!result) {\n      logger.throwArgumentError(\"unknown type: \".concat(JSON.stringify(name)), \"name\", name);\n    }\n    return result;\n  }\n  encodeData(type, value) {\n    return this.getEncoder(type)(value);\n  }\n  hashStruct(name, value) {\n    return keccak256(this.encodeData(name, value));\n  }\n  encode(value) {\n    return this.encodeData(this.primaryType, value);\n  }\n  hash(value) {\n    return this.hashStruct(this.primaryType, value);\n  }\n  _visit(type, value, callback) {\n    // Basic encoder type (address, bool, uint256, etc)\n    {\n      const encoder = getBaseEncoder(type);\n      if (encoder) {\n        return callback(type, value);\n      }\n    }\n    // Array\n    const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n    if (match) {\n      const subtype = match[1];\n      const length = parseInt(match[3]);\n      if (length >= 0 && value.length !== length) {\n        logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n      }\n      return value.map(v => this._visit(subtype, v, callback));\n    }\n    // Struct\n    const fields = this.types[type];\n    if (fields) {\n      return fields.reduce((accum, _ref3) => {\n        let {\n          name,\n          type\n        } = _ref3;\n        accum[name] = this._visit(type, value[name], callback);\n        return accum;\n      }, {});\n    }\n    return logger.throwArgumentError(\"unknown type: \".concat(type), \"type\", type);\n  }\n  visit(value, callback) {\n    return this._visit(this.primaryType, value, callback);\n  }\n  static from(types) {\n    return new TypedDataEncoder(types);\n  }\n  static getPrimaryType(types) {\n    return TypedDataEncoder.from(types).primaryType;\n  }\n  static hashStruct(name, types, value) {\n    return TypedDataEncoder.from(types).hashStruct(name, value);\n  }\n  static hashDomain(domain) {\n    const domainFields = [];\n    for (const name in domain) {\n      const type = domainFieldTypes[name];\n      if (!type) {\n        logger.throwArgumentError(\"invalid typed-data domain key: \".concat(JSON.stringify(name)), \"domain\", domain);\n      }\n      domainFields.push({\n        name,\n        type\n      });\n    }\n    domainFields.sort((a, b) => {\n      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n    });\n    return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n      EIP712Domain: domainFields\n    }, domain);\n  }\n  static encode(domain, types, value) {\n    return hexConcat([\"0x1901\", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);\n  }\n  static hash(domain, types, value) {\n    return keccak256(TypedDataEncoder.encode(domain, types, value));\n  }\n  // Replaces all address types with ENS names with their looked up address\n  static resolveNames(domain, types, value, resolveName) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Make a copy to isolate it from the object passed in\n      domain = shallowCopy(domain);\n      // Look up all ENS names\n      const ensCache = {};\n      // Do we need to look up the domain's verifyingContract?\n      if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n        ensCache[domain.verifyingContract] = \"0x\";\n      }\n      // We are going to use the encoder to visit all the base values\n      const encoder = TypedDataEncoder.from(types);\n      // Get a list of all the addresses\n      encoder.visit(value, (type, value) => {\n        if (type === \"address\" && !isHexString(value, 20)) {\n          ensCache[value] = \"0x\";\n        }\n        return value;\n      });\n      // Lookup each name\n      for (const name in ensCache) {\n        ensCache[name] = yield resolveName(name);\n      }\n      // Replace the domain verifyingContract if needed\n      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n        domain.verifyingContract = ensCache[domain.verifyingContract];\n      }\n      // Replace all ENS names with their address\n      value = encoder.visit(value, (type, value) => {\n        if (type === \"address\" && ensCache[value]) {\n          return ensCache[value];\n        }\n        return value;\n      });\n      return {\n        domain,\n        value\n      };\n    });\n  }\n  static getPayload(domain, types, value) {\n    // Validate the domain fields\n    TypedDataEncoder.hashDomain(domain);\n    // Derive the EIP712Domain Struct reference type\n    const domainValues = {};\n    const domainTypes = [];\n    domainFieldNames.forEach(name => {\n      const value = domain[name];\n      if (value == null) {\n        return;\n      }\n      domainValues[name] = domainChecks[name](value);\n      domainTypes.push({\n        name,\n        type: domainFieldTypes[name]\n      });\n    });\n    const encoder = TypedDataEncoder.from(types);\n    const typesWithDomain = shallowCopy(types);\n    if (typesWithDomain.EIP712Domain) {\n      logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n    } else {\n      typesWithDomain.EIP712Domain = domainTypes;\n    }\n    // Validate the data structures and types\n    encoder.encode(value);\n    return {\n      types: typesWithDomain,\n      domain: domainValues,\n      primaryType: encoder.primaryType,\n      message: encoder.visit(value, (type, value) => {\n        // bytes\n        if (type.match(/^bytes(\\d*)/)) {\n          return hexlify(arrayify(value));\n        }\n        // uint or int\n        if (type.match(/^u?int/)) {\n          return BigNumber.from(value).toString();\n        }\n        switch (type) {\n          case \"address\":\n            return value.toLowerCase();\n          case \"bool\":\n            return !!value;\n          case \"string\":\n            if (typeof value !== \"string\") {\n              logger.throwArgumentError(\"invalid string\", \"value\", value);\n            }\n            return value;\n        }\n        return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n      })\n    };\n  }\n}","map":{"version":3,"names":["getAddress","BigNumber","arrayify","hexConcat","hexlify","hexZeroPad","isHexString","keccak256","deepCopy","defineReadOnly","shallowCopy","Logger","version","logger","id","padding","Uint8Array","fill","NegativeOne","from","Zero","One","MaxUint256","hexPadRight","value","bytes","padOffset","length","slice","hexTrue","toHexString","hexFalse","domainFieldTypes","name","chainId","verifyingContract","salt","domainFieldNames","checkString","key","throwArgumentError","concat","JSON","stringify","domainChecks","toString","error","toLowerCase","Error","getBaseEncoder","type","match","signed","width","parseInt","String","boundsUpper","mask","boundsLower","add","mul","v","lt","gt","toTwos","encodeType","fields","map","_ref","join","TypedDataEncoder","constructor","types","Object","freeze","links","parents","subtypes","keys","forEach","uniqueNames","field","baseType","encoder","push","primaryTypes","filter","n","t","checkCircular","found","child","subtype","primaryType","st","sort","_types","getEncoder","_encoderCache","_getEncoder","subEncoder","result","encodedType","values","_ref2","unshift","encodeData","hashStruct","encode","hash","_visit","callback","reduce","accum","_ref3","visit","getPrimaryType","hashDomain","domain","domainFields","a","b","indexOf","EIP712Domain","resolveNames","resolveName","ensCache","getPayload","domainValues","domainTypes","typesWithDomain","message"],"sources":["/root/blockchain_projects/project_btp/node_modules/@ethersproject/hash/src.ts/typed-data.ts"],"sourcesContent":["import { TypedDataDomain, TypedDataField } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { id } from \"./id\";\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\n\nconst NegativeOne: BigNumber = BigNumber.from(-1);\nconst Zero: BigNumber = BigNumber.from(0);\nconst One: BigNumber = BigNumber.from(1);\nconst MaxUint256: BigNumber = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nfunction hexPadRight(value: BytesLike) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32\n    if (padOffset) {\n        return hexConcat([ bytes, padding.slice(padOffset) ]);\n    }\n    return hexlify(bytes);\n}\n\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\n\nconst domainFieldTypes: Record<string, string> = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\n\nconst domainFieldNames: Array<string> = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\n\nfunction checkString(key: string): (value: any) => string {\n    return function (value: any){\n        if (typeof(value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${ JSON.stringify(key) }`, `domain.${ key }`, value);\n        }\n        return value;\n    }\n}\n\nconst domainChecks: Record<string, (value: any) => any> = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(value: any) {\n        try {\n            return BigNumber.from(value).toString()\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function(value: any) {\n        try {\n            return getAddress(value).toLowerCase();\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value: any) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) { throw new Error(\"bad length\"); }\n            return hexlify(bytes);\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n}\n\nfunction getBaseEncoder(type: string): (value: any) => string {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1): width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne): Zero;\n\n            return function(value: BigNumberish) {\n                const v = BigNumber.from(value);\n\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${ type }`, \"value\", value);\n                }\n\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n\n            return function(value: BytesLike) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${ type }`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n\n    switch (type) {\n        case \"address\": return function(value: string) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function(value: boolean) {\n            return ((!value) ? hexFalse: hexTrue);\n        };\n        case \"bytes\": return function(value: BytesLike) {\n            return keccak256(value);\n        };\n        case \"string\": return function(value: string) {\n            return id(value);\n        };\n    }\n\n    return null;\n}\n\nfunction encodeType(name: string, fields: Array<TypedDataField>): string {\n    return `${ name }(${ fields.map(({ name, type }) => (type + \" \" + name)).join(\",\") })`;\n}\n\nexport class TypedDataEncoder {\n    readonly primaryType: string;\n    readonly types: Record<string, Array<TypedDataField>>;\n\n    readonly _encoderCache: Record<string, (value: any) => string>;\n    readonly _types: Record<string, string>;\n\n    constructor(types: Record<string, Array<TypedDataField>>) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n\n        defineReadOnly(this, \"_encoderCache\", { });\n        defineReadOnly(this, \"_types\", { });\n\n        // Link struct types to their direct child structs\n        const links: Record<string, Record<string, boolean>> = { };\n\n        // Link structs to structs which contain them as a child\n        const parents: Record<string, Array<string>> = { };\n\n        // Link all subtypes within a given struct\n        const subtypes: Record<string, Record<string, boolean>> = { };\n\n        Object.keys(types).forEach((type) => {\n            links[type] = { };\n            parents[type] = [ ];\n            subtypes[type] = { }\n        });\n\n        for (const name in types) {\n\n            const uniqueNames: Record<string, boolean> = { };\n\n            types[name].forEach((field) => {\n\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${ JSON.stringify(field.name) } in ${ JSON.stringify(name) }`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) { return ;}\n\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        } else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${ primaryTypes.map((t) => (JSON.stringify(t))).join(\", \") }`, \"types\", types);\n        }\n\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n\n        // Check for circular type references\n        function checkCircular(type: string, found: Record<string, boolean>) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${ JSON.stringify(type) }`, \"types\", types);\n            }\n\n            found[type] = true;\n\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) { return; }\n\n                // Recursively check children\n                checkCircular(child, found);\n\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n\n            delete found[type];\n        }\n        checkCircular(this.primaryType, { });\n\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n\n    getEncoder(type: string): (value: any) => string {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n\n    _getEncoder(type: string): (value: any) => string {\n\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return encoder; }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value: Array<any>) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n\n                return keccak256(hexConcat(result));\n            };\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value: Record<string, any>) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) { return keccak256(result); }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            }\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    encodeType(name: string): string {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${ JSON.stringify(name) }`, \"name\", name);\n        }\n        return result;\n    }\n\n    encodeData(type: string, value: any): string {\n        return this.getEncoder(type)(value);\n    }\n\n    hashStruct(name: string, value: Record<string, any>): string {\n        return keccak256(this.encodeData(name, value));\n    }\n\n    encode(value: Record<string, any>): string {\n        return this.encodeData(this.primaryType, value);\n    }\n\n    hash(value: Record<string, any>): string {\n        return this.hashStruct(this.primaryType, value);\n    }\n\n    _visit(type: string, value: any, callback: (type: string, data: any) => any): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return callback(type, value); }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v: any) => this._visit(subtype, v, callback));\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, <Record<string, any>>{});\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    visit(value: Record<string, any>, callback: (type: string, data: any) => any): any {\n        return this._visit(this.primaryType, value, callback);\n    }\n\n    static from(types: Record<string, Array<TypedDataField>>): TypedDataEncoder {\n        return new TypedDataEncoder(types);\n    }\n\n    static getPrimaryType(types: Record<string, Array<TypedDataField>>): string {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n\n    static hashStruct(name: string, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n\n    static hashDomain(domain: TypedDataDomain): string {\n        const domainFields: Array<TypedDataField> = [ ];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${ JSON.stringify(name) }`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n\n    static encode(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n\n    static hash(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n\n    // Replaces all address types with ENS names with their looked up address\n    static async resolveNames(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, resolveName: (name: string) => Promise<string>): Promise<{ domain: TypedDataDomain, value: any }> {\n        // Make a copy to isolate it from the object passed in\n        domain = shallowCopy(domain);\n\n        // Look up all ENS names\n        const ensCache: Record<string, string> = { };\n\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n\n        // Get a list of all the addresses\n        encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && ensCache[value]) { return ensCache[value]; }\n            return value;\n        });\n\n        return { domain, value };\n    }\n\n    static getPayload(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): any {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: Record<string, any> = { };\n        const domainTypes: Array<{ name: string, type:string }> = [ ];\n\n        domainFieldNames.forEach((name) => {\n            const value = (<any>domain)[name];\n            if (value == null) { return; }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n\n        const encoder = TypedDataEncoder.from(types);\n\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        } else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n\n        // Validate the data structures and types\n        encoder.encode(value);\n\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type: string, value: any) => {\n\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof(value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}